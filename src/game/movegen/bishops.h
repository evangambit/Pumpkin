#ifndef MOVEGEN_BISHOPS_H
#define MOVEGEN_BISHOPS_H

#include "../Position.h"
#include "../utils.h"
#include "sliding.h"

namespace ChessEngine {

namespace diag {

// For a given square, get all points along its southwest/northeast diagonal.
constexpr Bitboard kSouthWestDiagonalMask[65] = {
  0x1,
  0x102,
  0x10204,
  0x1020408,
  0x102040810,
  0x10204081020,
  0x1020408102040,
  0x102040810204080,
  0x102,
  0x10204,
  0x1020408,
  0x102040810,
  0x10204081020,
  0x1020408102040,
  0x102040810204080,
  0x204081020408000,
  0x10204,
  0x1020408,
  0x102040810,
  0x10204081020,
  0x1020408102040,
  0x102040810204080,
  0x204081020408000,
  0x408102040800000,
  0x1020408,
  0x102040810,
  0x10204081020,
  0x1020408102040,
  0x102040810204080,
  0x204081020408000,
  0x408102040800000,
  0x810204080000000,
  0x102040810,
  0x10204081020,
  0x1020408102040,
  0x102040810204080,
  0x204081020408000,
  0x408102040800000,
  0x810204080000000,
  0x1020408000000000,
  0x10204081020,
  0x1020408102040,
  0x102040810204080,
  0x204081020408000,
  0x408102040800000,
  0x810204080000000,
  0x1020408000000000,
  0x2040800000000000,
  0x1020408102040,
  0x102040810204080,
  0x204081020408000,
  0x408102040800000,
  0x810204080000000,
  0x1020408000000000,
  0x2040800000000000,
  0x4080000000000000,
  0x102040810204080,
  0x204081020408000,
  0x408102040800000,
  0x810204080000000,
  0x1020408000000000,
  0x2040800000000000,
  0x4080000000000000,
  0x8000000000000000,
  0x0,  // NO_SQUARE
};

// For a given square, get all points along its southeast/northwest diagonal.
constexpr Bitboard kSouthEastDiagonalMask[65] = {
  0x8040201008040201,
  0x80402010080402,
  0x804020100804,
  0x8040201008,
  0x80402010,
  0x804020,
  0x8040,
  0x80,
  0x4020100804020100,
  0x8040201008040201,
  0x80402010080402,
  0x804020100804,
  0x8040201008,
  0x80402010,
  0x804020,
  0x8040,
  0x2010080402010000,
  0x4020100804020100,
  0x8040201008040201,
  0x80402010080402,
  0x804020100804,
  0x8040201008,
  0x80402010,
  0x804020,
  0x1008040201000000,
  0x2010080402010000,
  0x4020100804020100,
  0x8040201008040201,
  0x80402010080402,
  0x804020100804,
  0x8040201008,
  0x80402010,
  0x804020100000000,
  0x1008040201000000,
  0x2010080402010000,
  0x4020100804020100,
  0x8040201008040201,
  0x80402010080402,
  0x804020100804,
  0x8040201008,
  0x402010000000000,
  0x804020100000000,
  0x1008040201000000,
  0x2010080402010000,
  0x4020100804020100,
  0x8040201008040201,
  0x80402010080402,
  0x804020100804,
  0x201000000000000,
  0x402010000000000,
  0x804020100000000,
  0x1008040201000000,
  0x2010080402010000,
  0x4020100804020100,
  0x8040201008040201,
  0x80402010080402,
  0x100000000000000,
  0x201000000000000,
  0x402010000000000,
  0x804020100000000,
  0x1008040201000000,
  0x2010080402010000,
  0x4020100804020100,
  0x8040201008040201,
  0x0,  // NO_SQUARE
};

const uint64_t kSouthEastShift[65] = {
  0, 1, 2, 3, 4, 5, 6, 7,
  0, 0, 1, 2, 3, 4, 5, 6,
  0, 0, 0, 1, 2, 3, 4, 5,
  0, 0, 0, 0, 1, 2, 3, 4,
  0, 0, 0, 0, 0, 1, 2, 3,
  0, 0, 0, 0, 0, 0, 1, 2,
  0, 0, 0, 0, 0, 0, 0, 1,
  0, 0, 0, 0, 0, 0, 0, 0,
  0,  // NO_SQUARE
};

const uint64_t kSouthWestShift[65] = {
  7, 6, 5, 4, 3, 2, 1, 0,
  6, 5, 4, 3, 2, 1, 0, 0,
  5, 4, 3, 2, 1, 0, 0, 0,
  4, 3, 2, 1, 0, 0, 0, 0,
  3, 2, 1, 0, 0, 0, 0, 0,
  2, 1, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  0,  // NO_SQUARE
};

// After calling "southeast_diag_to_byte", this array indicates
// which bits in the byte are off the board (and hence invalid to move to).
// Generated by
//
// for (int i = 0; i < 64; ++i) {
//   uint8_t byte = ~diag::southeast_diag_to_byte(SafeSquare(i), kUniverse);
//   std::cout << "0x" << std::hex << unsigned(byte) << ", ";
//   if (i % 8 == 7) {
//     std::cout << std::endl;
//   }
// }
const uint8_t kSouthEastOffBoard[65] = {
  0x0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe,
  0x80, 0x0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc,
  0xc0, 0x80, 0x0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8,
  0xe0, 0xc0, 0x80, 0x0, 0x80, 0xc0, 0xe0, 0xf0,
  0xf0, 0xe0, 0xc0, 0x80, 0x0, 0x80, 0xc0, 0xe0,
  0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x0, 0x80, 0xc0,
  0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x0, 0x80,
  0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x0,
  0x0,
};

const uint8_t kSouthWestOffBoard[65] = {
  0x7f, 0x3f, 0x1f, 0xf, 0x7, 0x3, 0x1, 0x0,
  0x3f, 0x1f, 0xf, 0x7, 0x3, 0x1, 0x0, 0x1,
  0x1f, 0xf, 0x7, 0x3, 0x1, 0x0, 0x1, 0x3,
  0xf, 0x7, 0x3, 0x1, 0x0, 0x1, 0x3, 0x7,
  0x7, 0x3, 0x1, 0x0, 0x1, 0x3, 0x7, 0xf,
  0x3, 0x1, 0x0, 0x1, 0x3, 0x7, 0xf, 0x1f,
  0x1, 0x0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f,
  0x0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f,
  0x0,
};

constexpr Bitboard kBishopMagic = bb(56) | bb(48) | bb(40) | bb(32) | bb(24) | bb(16) | bb(8) | bb(0);

uint8_t southeast_diag_to_byte(UnsafeSquare sq, Bitboard b) {
  b &= kSouthEastDiagonalMask[sq];
  b >>= kSouthEastShift[sq];
  return (b * kBishopMagic) >> 56;
}

uint8_t southeast_diag_to_byte(SafeSquare sq, Bitboard b) {
  return southeast_diag_to_byte(UnsafeSquare(sq), b);
}

uint8_t southwest_diag_to_byte(UnsafeSquare sq, Bitboard b) {
  b &= kSouthWestDiagonalMask[sq];
  b <<= kSouthWestShift[sq];
  return (b * kBishopMagic) >> 56;
}

uint8_t southwest_diag_to_byte(SafeSquare sq, Bitboard b) {
  return southwest_diag_to_byte(UnsafeSquare(sq), b);
}

Bitboard byte_to_southeast_diag(UnsafeSquare sq, Bitboard byte) {
  assert(byte < 256);
  byte *= kBishopMagic;
  byte <<= diag::kSouthEastShift[sq];
  byte &= kSouthEastDiagonalMask[sq];
  return byte;
}

Bitboard byte_to_southeast_diag(SafeSquare sq, Bitboard byte) {
  return byte_to_southeast_diag(UnsafeSquare(sq), byte);
}

Bitboard byte_to_southwest_diag(UnsafeSquare sq, Bitboard byte) {
  assert(byte < 256);
  byte *= kBishopMagic;
  byte >>= diag::kSouthWestShift[sq];
  byte &= kSouthWestDiagonalMask[sq];
  return byte;
}

Bitboard byte_to_southwest_diag(SafeSquare sq, Bitboard byte) {
  return byte_to_southwest_diag(UnsafeSquare(sq), byte);
}

}  // namespace diag

Bitboard compute_one_bishops_targets(SafeSquare from, const Bitboard occupied) {
  Location fromLoc = square2location(from);
  Bitboard r = kEmptyBitboard;
  {  // Southeast/Northwest diagonal.
    uint8_t enemiesByte = diag::southeast_diag_to_byte(from, occupied);
    uint8_t fromByte = diag::southeast_diag_to_byte(from, fromLoc);
    r |= diag::byte_to_southeast_diag(from, sliding_moves(fromByte, enemiesByte));
  }
  {  // Southwest/Northeast diagonal.
    uint8_t enemiesByte = diag::southwest_diag_to_byte(from, occupied);
    uint8_t fromByte = diag::southwest_diag_to_byte(from, fromLoc);
    r |= diag::byte_to_southwest_diag(from, sliding_moves(fromByte, enemiesByte));
  }
  return r;
}

Bitboard compute_bishoplike_targets(Bitboard bishopLikePieces, const Bitboard occupied) {
  Bitboard r = kEmptyBitboard;

  while (bishopLikePieces) {
    const SafeSquare from = pop_lsb_i_promise_board_is_not_empty(bishopLikePieces);
    r |= compute_one_bishops_targets(from, occupied);
    // Location fromLoc = square2location(from);

    // {  // Southeast/Northwest diagonal.
    //   uint8_t enemiesByte = diag::southeast_diag_to_byte(from, occupied);
    //   uint8_t fromByte = diag::southeast_diag_to_byte(from, fromLoc);
    //   r |= diag::byte_to_southeast_diag(from, sliding_moves(fromByte, enemiesByte));
    // }
    // {  // Southwest/Northeast diagonal.
    //   uint8_t enemiesByte = diag::southwest_diag_to_byte(from, occupied);
    //   uint8_t fromByte = diag::southwest_diag_to_byte(from, fromLoc);
    //   r |= diag::byte_to_southwest_diag(from, sliding_moves(fromByte, enemiesByte));
    // }

  }
  return r;
}

template<Color US>
Bitboard compute_bishoplike_targets(const Position& pos, Bitboard bishopLikePieces) {
  const Bitboard occupied = (pos.colorBitboards_[US] | pos.colorBitboards_[opposite_color<US>()]) & ~bishopLikePieces;
  return compute_bishoplike_targets(bishopLikePieces, occupied);
}

Bitboard compute_bishop_check_mask(const SafeSquare kingSq, const Bitboard everyone) {
  Bitboard checkMask = kEmptyBitboard;
  const Location king = bb(kingSq);
  {  // Southeast/Northwest diagonal.
    uint8_t occupied = diag::southeast_diag_to_byte(kingSq, everyone & ~king);
    uint8_t fromByte = diag::southeast_diag_to_byte(kingSq, king);
    checkMask |= diag::byte_to_southeast_diag(kingSq, sliding_moves(fromByte, occupied));
  }
  {  // Southwest/Northeast diagonal.
    uint8_t occupied = diag::southwest_diag_to_byte(kingSq, everyone & ~king);
    uint8_t fromByte = diag::southwest_diag_to_byte(kingSq, king);
    checkMask |= diag::byte_to_southwest_diag(kingSq, sliding_moves(fromByte, occupied));
  }
  return checkMask;
}

template<Color US, MoveGenType MGT>
ExtMove *compute_bishop_like_moves(const Position& pos, ExtMove *moves, Bitboard target, const PinMasks& pm, const Bitboard bishopCheckMask, const Bitboard rookCheckMask) {
  constexpr ColoredPiece myBishopPiece = (US == Color::WHITE ? ColoredPiece::WHITE_BISHOP : ColoredPiece::BLACK_BISHOP);
  constexpr ColoredPiece myQueenPiece = (US == Color::WHITE ? ColoredPiece::WHITE_QUEEN : ColoredPiece::BLACK_QUEEN);
  const Bitboard friends = pos.colorBitboards_[US];
  const Bitboard enemies = pos.colorBitboards_[opposite_color<US>()];
  const Bitboard everyone = friends | enemies;
  const Bitboard myQueens = pos.pieceBitboards_[myQueenPiece];
  Bitboard bishopLikePieces = pos.pieceBitboards_[myBishopPiece] | myQueens;

  // TODO: diagonal pins.
  bishopLikePieces &= ~(pm.horizontal | pm.vertical);

  while (bishopLikePieces) {
    const SafeSquare from = pop_lsb_i_promise_board_is_not_empty(bishopLikePieces);
    const Piece piece = cp2p(pos.tiles_[from]);
    Location fromLoc = square2location(from);

    Bitboard tos = kEmptyBitboard;

    const Bitboard required = target
      // Target (above) handles checks. The lines below handle pins.
      & select((pm.northwest & fromLoc) > 0, pm.northwest, kUniverse)
      & select((pm.northeast & fromLoc) > 0, pm.northeast, kUniverse);


    {  // Southeast/Northwest diagonal.
      uint8_t occ = diag::southeast_diag_to_byte(from, enemies | (friends & ~fromLoc));
      uint8_t fromByte = diag::southeast_diag_to_byte(from, fromLoc);
      tos |= diag::byte_to_southeast_diag(from, sliding_moves(fromByte, occ)) & ~friends;
    }
    {  // Southwest/Northeast diagonal.
      uint8_t occ = diag::southwest_diag_to_byte(from, enemies | (friends & ~fromLoc));
      uint8_t fromByte = diag::southwest_diag_to_byte(from, fromLoc);
      tos |= diag::byte_to_southwest_diag(from, sliding_moves(fromByte, occ)) & ~friends;
    }

    tos &= required;

    if (MGT == MoveGenType::ALL_MOVES) {
      // no-op
    }
    else if (MGT == MoveGenType::CAPTURES) {
      tos &= enemies;
    }
    else if (MGT == MoveGenType::CHECKS_AND_CAPTURES) {
      tos &= enemies | bishopCheckMask | value_or_zero((fromLoc & myQueens) > 0, rookCheckMask);
    }

    while (tos) {
      SafeSquare to = pop_lsb_i_promise_board_is_not_empty(tos);
      *moves++ = ExtMove(piece, pos.tiles_[to], Move{from, to, 0, MoveType::NORMAL});
    }
  }

  return moves;
}

}  // namespace ChessEngine

#endif  // MOVEGEN_BISHOPS_H
